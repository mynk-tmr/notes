**MongoDB**
* **open-source document** database. It stores data in flexible BSON (binary encoded json) format. 
* BSON supports **more types**, encodes type and length info too to make parsing easier.
* written in C++ and  uses **journaling** for backup
* **Profiler**:  collects detailed information about Database Commands executed against a running mongod instance into a `system.profile` collection

**Advantages over SQL**
- easy to store and query large volumes of unstructured data.
- flexible data schema
- highly scalable horizontally using sharding
- indexing, in-memory cache for faster query and sorting

**How to use it in NodeJS ?**
MongoDB provides official **driver** support for Node.js.
```js
import {MongoClient} from 'mongodb'
const myDB;
MongoClient.connect(db_url, (err, db) => !err & myDB = db  )
```

**Document** - basic unit of data in MongoDB. Similar to a **row**. Use BSON format.
**Collection** - A group of documents, similar to a **table**.
**Database** - A physical container for collections. Doesn't exist until a document is added.
**Instance** - running software that allows interaction with 1 or more databases

**Namespace** : db name + collection name

**Sharding**
* procedure of splitting data records across multiple machines. (horizontal scaling -> new nodes). 
* If a shard is down and you do query, an error occurs unless you set a *partial query* option. But if a shard is slow them Mongodb will wait
* for concurrency, reader-writer locks are used. Multiple readers can access a resource (db or collection) but only 1 can do single write operation.

**Replica set**
- a group of mongo instances that host the same data set. 
- 1 primary/master node : can accept write queries
- several slave/secondary nodes: read only nodes that replicate from primary

**BSON types**
- String (utf-8)
- Integer 
- Double
- Boolean 
- Array 
- Date : datetime stored in ms (from epoch)
- Null: missing/unknown value
- **Embedded Documents** store documents inside other documents. Can do primary-foreign key relationship. `{ address: { street: "123 Main St", city: "New York" } }
- **Object IDs** : special datatype used for document IDs, IDs are autogenerated untill explicitly defined.
    `{ _id: ObjectId() }`

**Common Methods**
* `insertOne, insertMany` : insert doc into collection
* `find` : queries a collection and returns docs. Also for **projection**
* `deleteOne, deleteMany`: query and delete matching docs
* `updateOne, update`: query and update docs

```js
let cl = db.users; //get collection

cl.insertOne(obj) cl.insertMany(array_of_obj)
cl.find({}) //get all  
cl.find(q)
cl.update(q, {$set: {age: 20}})

const cursor = cl.find({})
cursor.sort({age: -1}) // sort by age DESC ; for ASC 1
cursor.limit(10) 

//PAGINATION
cursor.skip(10).limit(10)
```

**Projection** : 
* to specify fields to be returned from matched documents, you can include a projection document.
* `_id` is always returned by default
* e.g. `cursor.project(proj_doc)  or find(q, proj_doc)`

**Indexes in collection** : `cl.createIndex({name: 1}) // Ascending index`
* allow query engine to quickly find and sort documents by their indexed fields without having to scan every document in the collection.
* index is created in background and does not block reads/writes.
* *storage overhead* : Indexes consume disk space and memory to store
- slows down *write operations* as indexes also need to be updated
- use only for queried/sort by fields
- Compound indexes can be created on multiple fields.

**Covered query** : satisfies 3 conditions:
- all queried fields are part of index
- all fields returned in results are in same index.
- no fields in query are equal to null
- Makes query execution faster because 
	- indexes are stored in RAM or sequentially located on disk.
	- No need to look in document if indexed fields are returned

```ts
db.inventory.createIndex( { type: 1, item: 1 } )
db.inventory.find(
   { type: "food", item:/^c/ },
   { item: 1, _id: 0 }
)
```

**Query Operators** : used to build queries. Given as `key` of query with a value.
* **Comparison** : `$eq $ne $gt $gte $lt $lte $in $nin` e.g. `$in : ['A', 'B']`
* **Logical**: joins query clauses with `$and $or $nor $not` e.g.  `$and : [query1, query2]`
* **Element**: assert if field exists or certain type. `$exists` `$type` `$jsonSchema`
* **Evaluation**: supports expressions in queries. `$expr` `$mod` `$regex` `$text` `$where`
* **Array**: `$all` `$size` `$elemMatch`

**Query object example**
```js
q = { age: { $gte: 18, $lt : 66} } // field : {op : value} 
q = {
   $and: [{ qty: { $ne: 0 } }, { instock: {$eq : true} }]
}
$type: "array"
$exists: true
$mod: [ 4, 0 ]  // qty % 4 == 0
$regex : /acme*/
$text: {
	$search: "lava", $language: <string>, $caseSensitive: false,
}

$where //find documents that satisfy a JavaScript expression.
q = { $where: function() { return this.qty > 0 } }

$all : ['mains', 'gs1'] //array has all
$size: 5 //array len 5
$elemMatch: { product: "xyz", score: { $gte: 8 } } //array matches all conditions
```

**Update operators**
```js
$inc: {qty: 2, price: -2}}) //increment by number
$min : {low : 200 } //updates original low to 200 if it's >200
$max
$push: { scores: 95 } //add 95 to scores[] field
$pull $pullAll //remove first , all occurences of 95 from scores
$rename: {'scores' : 'points'}
```

**Projection examples
```js
project({ item: 0 }); //return all fields except item
project({ "colors.$": 1 }) //return 1st matched ; colors : ['red']
project({ comments: { $slice: [1,3] } }) 
project({ $comment : 'my comment' }) //insert comment in projected docs
```

**Authentiation with JWT**
* **Json web tokens :** *stateless* method of securely transmitting info as JSON. Stateless means each request is *self-contained* and requires no session data storage
* Parts of JWT
	* **header** : token type and hash algo used
	* **payload** : auth data (like `userID` in database) 
	* **signature** :  to verify token’s integrity (output of `jwt.sign`)
* Working of auth
	* *Token Generation*: server generates a token identifying user and session (like expiry date)
	- *Token Storage:*  sent to client as `http-only, secure` cookie and stored there
	- *Access Control*: In all requests, client sends jwt cookie to verify permission
	- *Token Expiration:* obtain new JWT
- when to use: stateless api, microservices, reducing database calls
- when NOT: payment related data (credit card no.) should never be sent in payload

**TailwindCSS**
* utility-first CSS framework that provides pre-defined CSS classes to style UI
* provides a `config` file to customise design system. It includes variables for `colors, fonts, animations` etc
* **Utility** classes are small, single-purpose classes that provide a specific styling utility e.g. `m-2` `p-3`
* **Component** classes are larger classes that provide a collection of styles for a specific component. e.g. `btn` `card`
* It uses **purge** to create files for production that removes any unused classes t to minimize CSS file size
* Common tips
	* using purge
	* caching to speed up builds

**GraphQL
- a query language and server-side runtime.
- gives clients exactly the data they request and no more.
- can pull data from multiple sources in a single API call.

**Best  practices to develop RESTful web services**
- use `JSON` whenever possible 
- use `heirarchy` 
- use appropriate error codes
- use `filter` and `pagination` for large datasets to avoid blockage
- role-based access controls
- caching
- API versioning:  to make seamless changes in endpoints. Semantic versioning can be followed. Use `/v1`,`/v2`, etc at the beginning of the API path

**How to design RESTful API/system ?**
1. create data schema of resources (key-values, types, classes etc.)
2. `Content-Type` of each resource
3. request format to perform CRUD operations eg. `POST user/:id/todo/new <body>`
4. reponse format that server sends for each e.g. `200 (OK) Content-type:text/css <body>`

**Types of Test**
* **Unit tests** : test small isolated parts of codebase. Interaction with other units is *mocked* eg. class, methods, etc.
- **Integration tests**: test interaction across *real* unit-tested portions of code like modules, database, etc.
- **End to End tests**: replicates a user behavior with the software.
- **Performance tests**: evaluate system's performance under different conditions, identify memory leaks, bottlenecks,

**GIT**
* has two main data structures - **object store & index,** stored in `.git` folder
* **Git objects** represent a data structure and have a unique hash-id. Types
	- **Blobs** (file structures)
	- **Trees** ( directory structure)
	    - **tree-ish** is anything that ultimately leads to a tree object. e.g. **branch, tag**
	    - **commit-ish** (type of tree-ishes) e.g. `HEAD, sha-1 hash`
	    - **combined** : tree-ish:path e.g. `main:assets/hello.js`
- A `branch` is pointer to last commit made on branch. Internally, it's a **file** that contains sha-1 checksum of last commit
- new `branch` -> new copy
- `HEAD` is pointer to current local branch ; when it points to a specific commit -> detached

**2 ways to integrate branches**
- merge : combine end-points and point to it.
	- **fast-forward**: move main branch's tip forward onto feat tip
	- **2 parent**: new commit is created (merge commit)
- rebase : replay all commits in a particular branch over a different branch


`package.json` contains metadata about the project and its dependencies. It helps npm to handle project
`package-lock.json` records exact version of each installed package & dependencies -- to build identical dependency tree in every dEV environment. PUSH this.

**Version range**
- `~1.0.4` => stick to minor (++patches)
- `^1.1.0` => stick to major (_default ; ++features_)
- `2.3.2` => exactly this, no auto-upgrade

**Properties of package.json**
```json
"name" //url safe project name
"version" //1.0.2
"description" 
"main": "index.js"  //entry point of app
"config": {}  //like port
"dependencies": {},
"scripts"
```

**npm scripts** : written in `scripts` field. key is *life-cycle* event, value is cmd to run. Always runs from *root* dir
```js
//define pre & post scripts
premyscript, myscript, postmyscript

//run scripts of dependencies
npm explore pkg -- npm run cmd

//useful inbuilt
prestart, start, poststart, stop, restart, build
```

