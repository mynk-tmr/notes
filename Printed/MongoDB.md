MongoDB is **open-source NoSQL document store** database. It stores data in flexible JSON-like documents rather than tables with a fixed schema like SQL databases. 

It's written in C++. MongoDB uses BSON to represent document structures.
MMAPv1 and WiredTiger are two storage engine used by MongoDB.

**BSON** is a binary encoded JSON. JSON is human-readable, but supports fewer data types. BSON encodes type and length information, too, making it easier for machines to parse.

**Advantages over SQL**
- easy to store and query large volumes of unstructured data.
- flexible data schema
- highly scalable horizontally using sharding
- indexing, in-memory cache for faster query and sorting

MongoDB provides official **driver** support for C, C++, C#, Java, Node.js. Can be used with them

We can achieve primary key-foreign key relationship by embedding one document inside another. 

MongoDB doesn't use traditional locking or complex transaction with Rollback.

ObjectID is a 12-byte BSON type. These are:
- 4 bytes value representing seconds
- 3 byte machine identifier
- 2 byte process id
- 3 byte counter

**Namespace** : concatenation of the database name and the collection name
**Journaling**: for backup
**Profiler**:  collects detailed information about Database Commands executed against a running mongod instance into a `system.profile` collection

MongoDB uses reader-writer locks for **concurrency**. Reader-writer locks allow concurrent readers shared access to a resource, such as a database or collection, but give exclusive access to a single write operation.

**Sharding** is a procedure of splitting data records across multiple machines. (horizontal scaling -> new nodes). If a shard is down and you do query, an error occurs unless you set a *partial query* option. But if a shard is slow them Mongos will wait

##### Replica set
- a group of mongo instances that host the same data set. 
- 1 primary/master node : can accept write
- several slave/secondary nodes: read only nodes that replicate from primary

**Document** - basic unit of data in MongoDB. Similar to a row in an RDBMS table. Documents are stored in JSON-like (BSON) format with field-value pairs.  

**Collection** - A group of documents, similar to a table in RDBMS.
    
**Database** - A physical container for collections. Each MongoDB server typically has multiple databases.

MongoDB supports these *data types* for fields in documents:
- **String** - UTF-8 encoded string for storing text `{ name: "John Doe" }`
- **Integer** - Used for numeric values
- **Boolean** - Stores true/false values.
- **Double** - 64-bit floating point value for decimals.
- **Arrays** - Stores lists of values in a single key.
- **Embedded Documents** - Stores documents inside other documents.
    `{ address: { street: "123 Main St", city: "New York" } }
- **Object IDs** - Special datatype used for document IDs, IDs are autogenerated untill explicitly defined.
    `{ _id: ObjectId() }`
- **Dates** - Date and time stored as milliseconds since Unix epoch.
    `{ createdAt: new Date() }`
- **Null** - Represents missing or unknown data
    `{ middleName: null }`


To insert a document into a collection:  

```js
db.users.insertOne({ name: "John", age: 30 })

db.users.insertMany([ {name: "John", age: 30}, {name: "Jane", age: 27}])
```

To query a *collection*, use `find()` : 

```js
db.users.find({}) // returns all documents
db.users.find({age: {$gte: 18, $lt : 66}})

//COMPARISON OPS
$eq $ne $gt $gte $lt $lte 
$in $nin //match 1 / none of array values

//LOGICAL OPS
//joins query clauses with logical and/or/nor/or and return doc that satisfy
db.example.find({
   $and: [{ qty: { $ne: 0 } }, { instock: {$eq : true} }]
})

//ELEMENT OPS
db.spices.find( { saffron: { $exists: true } } )
db.papers.find( { colors: { $type: "array" } } ) //if field of specified type

//EVALUATION OPS
db.supplies.find({ $expr: { $lt:[ discountedPrice, 5] }}); //allows expressions

$jsonSchema //find documents with given JSON Schema.
$mod //perform modulo  e.g. 
db.inventory.find({ qty: { $mod: [ 4, 0 ]}}) //division by 4 yeilds 0

$regex : /acme*/
$text: {
	$search: "lava",
	$language: <string>,
	$caseSensitive: false,
}

$where //find documents that satisfy a JavaScript expression.
db.players.find({ $where: function() {
   return (this.name.startsWith('st'))
}});

//ARRAY OPS
tags: {$all : ['mains', 'gs1']} //all tag should match
tags : {$size: 5}
tags: { $elemMatch: { product: "xyz", score: { $gte: 8 }}} //element in array field matches all conditions
```

### PROJECTION

To limit/specify fields to be returned from matched documents, you can include a projection document. `_id` is always returned by default

```js
db.collection('inventory').find({ status: 'A'})
  .project({ item: 1, status: 1, _id: 0 }); //return only item, status fields and not _id

db.collection('inventory').find({ status: 'A'})
  .project({ item: 0 }); //return all fields except item


//PROJECTION OPERATORS
$ //project 1st matching array element based on a condition.
db.students.find({ sem: 1, grades: { $gte: 85 } },{ "grades.$": 1 })

$elemMatch //project 1st matching array element based on conditions
db.players.find( {}, { games: { $elemMatch: { score: { $gt: 5 } } } })

$slice //limits no. of elements projected from array
db.posts.find({},{ comments: { $slice: [1,3] }}) //skip 1 ele, then return 3
$slice: [-1, 3] //start from last, return 3

//to have comments in returned documets
db.records.find({
     x: { $mod: [ 2, 0 ] },
     $comment: "Find even X."
})
```

### Updating Documents

```js
db.users.update({name: "John"}, {$set: {age: 20}})
$inc: {qty: 2, price: -2}}) //increment by number
$min : {low : 200 } //updates original low to 200 if it's >200
$max
$push: { scores: 95 } //add 95 to scores[] field
$pull $pullAll //remove first , all occurences of 95 from scores
$rename: {'scores' : 'points'}

db.users.updateOne
```

### Deleting

```ts
db.users.deleteOne
db.users.deleteMany({status: "inactive"})
```

### Misc

```js
const cursor = db.users.find({})

cursor.sort({age: -1}) // sort by age DESC ; for ASC 1
cursor.limit(10) // only return 10 docs

//PAGINATION
cursor.skip(10).limit(10) // skip 10, limit 10
```

##### INDEXES

Indexes allow the MongoDB query engine to quickly find and sort documents by their indexed fields without having to scan every document in the collection.

```ts
db.users.createIndex({name: 1}) // Ascending index

db.users.find({name: {$gt: "I"}})  //all docs with name J K L ..
```

The index will be created in the background and does not block reads/writes.

**Some considerations**
- *storage overhead* : Indexes consume disk space and memory to store
- slows down *write operations* as indexes also need to be updated
- use only for queried/sort by fields
- Compound indexes can be created on multiple fields.

##### Covered query
- satisfies 3 conditions:
	- all queried fields are part of index
	- all fields returned in results are in same index.
	- no fields in query are equal to null
- Pros
	- makes query execution faster because indexes are stored in RAM or sequentially located on disk.
	- No need to look in document if indexed fields are returned

```ts
db.inventory.createIndex( { type: 1, item: 1 } )
db.inventory.find(
   { type: "food", item:/^c/ },
   { item: 1, _id: 0 }
)
```
